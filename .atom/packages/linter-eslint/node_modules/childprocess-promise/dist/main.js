'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var Cluster = require('cluster');
var ChildProcess = require('child_process');
var Communication = require('sb-communication');

var CPPromise = (function () {
  function CPPromise(target, debug) {
    var _this = this;

    _classCallCheck(this, CPPromise);

    if (typeof target === 'string') {
      this.target = ChildProcess.fork(target);
    } else if (target) {
      this.target = target;
    } else {
      this.target = process;
    }
    this.communication = new Communication(debug);
    this.sendCallback = function (data) {
      _this.target.send(data);
    };
    this.target.on('message', function (message) {
      _this.communication.gotMessage(_this.sendCallback, message);
    });
  }

  _createClass(CPPromise, [{
    key: 'on',
    value: function on(type, callback) {
      return this.communication.on(type, callback);
    }
  }, {
    key: 'request',
    value: function request(type, message) {
      return this.communication.request(this.sendCallback, type, message);
    }
  }, {
    key: 'disconnect',
    value: function disconnect() {
      this.target.disconnect();
    }
  }, {
    key: 'kill',
    value: function kill(sig) {
      this.target.kill(sig);
    }
  }], [{
    key: 'randomId',
    value: function randomId() {
      return (Math.random().toString(36) + '00000000000000000').slice(2, 7 + 2);
    }
  }, {
    key: 'fork',
    value: function fork(env) {
      return new CPPromise(Cluster.fork(env || process.env));
    }
  }]);

  return CPPromise;
})();

CPPromise.isWorker = Cluster.isWorker;
CPPromise.isMaster = !CPPromise.isWorker;

module.exports = CPPromise;